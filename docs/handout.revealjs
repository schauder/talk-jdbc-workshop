<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta name="author" content="Jens Schauder, September 2019" /><title>Spring Data JDBC Workshop</title><meta content="yes" name="apple-mobile-web-app-capable" /><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style" /><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui" name="viewport" /><link href="reveal.js-3.7.0/css/reveal.css" rel="stylesheet" /><link rel="stylesheet" href="theme/schauderhaft.css" id="theme" /><!--This CSS is generated by the Asciidoctor-Reveal.js converter to further integrate AsciiDoc's existing semantic with Reveal.js--><style type="text/css">.reveal div.right {
  float: right;
}

/* callouts */
.conum[data-value] {display:inline-block;color:#fff!important;background-color:rgba(50,150,50,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}</style><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.3.0/css/font-awesome.min.css" /><style>/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
pre.CodeRay{background:#f7f7f8}
.CodeRay .line-numbers{border-right:1px solid currentColor;opacity:.35;padding:0 .5em 0 0}
.CodeRay span.line-numbers{display:inline-block;margin-right:.75em}
.CodeRay .line-numbers strong{color:#000}
table.CodeRay{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.CodeRay td{vertical-align:top;line-height:inherit}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.code{padding:0 0 0 .75em}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}</style><link href="reveal.js-3.7.0/lib/css/zenburn.css" rel="stylesheet" /><script>var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? "reveal.js-3.7.0/css/print/pdf.css" : "reveal.js-3.7.0/css/print/paper.css";
document.getElementsByTagName( 'head' )[0].appendChild( link );</script><!--[if lt IE 9]><script src="reveal.js-3.7.0/lib/js/html5shiv.js"></script><![endif]--></head><body><div class="reveal"><div class="slides"><section class="title" data-state="title"><h1>Spring Data JDBC Workshop</h1><p class="author"><small>Jens Schauder, September 2019</small></p></section><section id="_what_is_spring_data"><h2>What is Spring Data?</h2><div class="paragraph"><p>Spring Data offers APIs for persisting data to various data stores.
Some examples are MongoDB, Neo4J, Elastic Search, Relational Databases using JPA or JDBC and many more.</p></div>
<div class="paragraph"><p>The API is inspired by Domain Driven Design and comes in most cases with two levels:</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>The Repository abstraction.
A <code>Repository</code> looks somewhat like a collection of all instances of a given type with methods to add, find and delete instances.
Repository can be extended in various ways many of which just require defining additional methods to a <code>Repository</code> without actually implementing them.
The implementation will be provided by Spring Data.</p></li><li><p>The Template abstraction.
A template is a class that allows more direct access to special features of the underlying persistence technology.</p></li></ol></div>
<div class="paragraph"><p>Spring Data does not try to unify the access to all these stores in order to make them interchangeable.
Such an endeavor is bound to fail since each an every persistence store has features that are impossible or very expensive to emulate in another.
A unifying API would either need to provide such an emulation or not offer any of these features at all.</p></div>
<div class="paragraph"><p>Instead Spring Data tries to provide a consistent API that makes it easy for users of one Spring Data variant to learn another while encouraging good application design at the same time.</p></div></section>
<section><section id="_first_spring_data_jdbc_example"><h2>First Spring Data JDBC example</h2></section><section id="_create_a_spring_starter_project"><h2>Create a Spring Starter Project</h2><div class="paragraph"><p>With Spring Tools and IntelliJ you can do this directly in the IDE.
This only describes the web based variant.</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>Goto <a href="https://start.spring.io" class="bare">https://start.spring.io</a></p></li><li><p>Select</p><div class="ulist"><ul><li><p>latest Milestone version of Spring Boot (2.2.0.M5)</p></li><li><p>add HyperSQL Database</p></li><li><p>add Lombok</p></li><li><p>add JDBC API</p></li><li><p>generate the project</p></li><li><p>unpack</p></li><li><p>open in the IDE</p></li></ul></div></li></ol></div>
<div class="paragraph"><p>Some Notes on the dependencies:</p></div>
<div class="paragraph"><p><strong>Lombok</strong> isn&#8217;t really needed but it makes the code nice and concise.
If you don&#8217;t like Lombok you can create constructors, <code>equals</code> and <code>hashcode</code> implementations with your IDE just as well.</p></div>
<div class="paragraph"><p><strong>JDBC API</strong> is actually not what we need. But it&#8217;s close and we&#8217;ll change it in a moment.</p></div></section><section id="_add_spring_data_jdbc"><h2>Add Spring Data JDBC</h2><div class="paragraph"><p>Open the <code>pom.xml</code>.
Find the following section:</p></div>
<pre class="CodeRay listingblock"><code class="xml language-xml">&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
	&lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<div class="paragraph"><p>And replace it with this one.</p></div>
<pre class="CodeRay listingblock"><code class="xml language-xml">&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
	&lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre></section><section id="_build_everything"><h2>Build everything</h2><div class="paragraph"><p>From the commandline run</p></div>
<pre class="CodeRay listingblock"><code>./mvnw clean install</code></pre>
<div class="paragraph"><p>Or run the <code>DemoApplication</code> to make sure everything works and can be downloaded.</p></div></section><section id="_create_an_entity_and_a_repository"><h2>Create an entity and a repository</h2><div class="paragraph"><p>Create an entity.</p></div>
<pre class="CodeRay listingblock"><code class="java language-java">import org.springframework.data.annotation.Id;

@ToString
@EqualsAndHashCode
class Speaker {
	@Id
	Long id;
	String name;
}</code></pre>
<div class="paragraph"><p>Create a repository</p></div>
<pre class="CodeRay listingblock"><code class="java language-java">import org.springframework.data.repository.CrudRepository;

interface SpeakerRepository extends CrudRepository&lt;Speaker, Long&gt; { }</code></pre>
<div class="paragraph"><p>And check that you can inject it, for example by changing the DemoApplication as follows:</p></div>
<pre class="CodeRay listingblock"><code class="java language-java">@SpringBootApplication
public class DemoApplication implements CommandLineRunner {

	@Autowired
	SpeakerRepository speakers;

	public static void main(String[] args) {
		SpringApplication.run(DemoApplication.class, args);
	}


	@Override
	public void run(String... args) {
		if (speakers != null) {
			System.out.println("I'm running and have a speakers repository");
		} else {
			System.out.println("drats, something is wrong");
		}
	}
}</code></pre>
<div class="paragraph"><p>We implement the <code>CommandLineRunner</code> interface in order to execute some code at start up.
Add an <code>@Autowired</code> field of type <code>SpeakerRepository</code> and check that it is not <code>null</code>.</p></div></section><section id="_actually_use_the_repository"><h2>Actually Use the Repository.</h2><div class="paragraph"><p>Add the following to the <code>run</code> method in order to create a Speaker and persist it:</p></div>
<pre class="CodeRay listingblock"><code class="java language-java">Speaker martin = new Speaker();
martin.name = "Martin Fowler";

Speaker saved = speakers.save(martin);

System.out.println(saved);</code></pre>
<div class="paragraph"><p>If you execute the changed application you&#8217;ll get an exception like the following:</p></div>
<pre class="CodeRay listingblock"><code>user lacks privilege or object not found: SPEAKER in statement [INSERT INTO speaker (name) VALUES (?)]</code></pre>
<div class="paragraph"><p>This is because we didn&#8217;t create any tables yet!</p></div>
<div class="paragraph"><p>Add the following <code>schema.sql</code> to the <code>source/main/resources</code> folder to fix this.</p></div>
<pre class="CodeRay listingblock"><code class="sql language-sql">CREATE TABLE SPEAKER
(
  ID   BIGINT GENERATED BY DEFAULT AS IDENTITY (START WITH 1) PRIMARY KEY,
  NAME VARCHAR(200)
);</code></pre></section><section id="_add_some_logging"><h2>Add some Logging</h2><div class="paragraph"><p>In order to better understand what is going on we should add some logging.
Add the following line to your <code>application.properties</code> file.</p></div>
<pre class="CodeRay listingblock"><code>logging.level.org.springframework.jdbc.core=TRACE</code></pre>
<div class="paragraph"><p>All execution of SQL statements happen through Springs <code>JdbcTemplate</code> so it&#8217;s logging facility may be used for gaining insights what statements get executed.</p></div></section><section id="_move_our_experiments_to_a_test"><h2>Move our Experiments to a Test.</h2><div class="paragraph"><p>Moving our experiments to a test makes it easier to &#8230;&#8203; well &#8230;&#8203; test stuff.
Create a class like the following an run it in your IDE.</p></div>
<pre class="CodeRay listingblock"><code class="java language-java">import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.data.jdbc.DataJdbcTest;
import org.springframework.test.context.junit4.SpringRunner;

import static org.assertj.core.api.Assertions.*;

@RunWith(SpringRunner.class)
@DataJdbcTest
public class SpeakerRepositoryTests {

	@Autowired
	SpeakerRepository speakers;

	@Test
	public void saveInstance() {

		Speaker martin = new Speaker();
		martin.name = "Martin Fowler";

		Speaker saved = speakers.save(martin);

		assertThat(saved.id).isNotNull();
	}
}</code></pre>
<div class="paragraph"><p>Make sure to remove the save operation in the <code>CommandLineRunner</code>.
Otherwise it will run before each test and mess with your test data.</p></div></section><section id="_wrap_up_of_the_first_example"><h2>Wrap up of the first example</h2><div class="paragraph"><p>In order to use Spring Data JDBC in a Spring Boot application you need to do the following:</p></div>
<div class="ulist"><ul><li><p>add <code>spring-boot-starter-data-jdbc</code> to your dependencies.</p></li><li><p>create entities.</p></li><li><p>create repositories.</p></li><li><p>inject the latter where needed.</p></li><li><p>persist away.</p></li></ul></div></section></section>
<section id="_spring_data_jdbc_vs_spring_data_jpa"><h2>Spring Data JDBC vs Spring Data JPA</h2><div class="paragraph"><p>Why are there two Spring Data modules for the same underlying technology: Relational databases?</p></div>
<div class="paragraph"><p>JPA is pretty much the default technology when accessing RDBMSes on the JVM.
This does not mean it is without problems.</p></div>
<div class="ulist"><ul><li><p>It considers the complete domain object graph a single graph.
So you might load a few instances with a query and then navigate the whole database using objects.
While this is possible it is very inefficient.
Either you rely on lazy loading which means the required data is loaded piece by piece.
Also a simple call of an getter might trigger an arbitrary amount of SQL statements.
Or you rely on eager loading which leads to large amounts of data loaded even if not needed.</p></li><li><p>Similar to lazy loading JPA uses write behind to dynamically determine when to write back to the database.
This can lead to confusing scenarios where the user thinks data is stored in the database but it actually isn&#8217;t.</p></li><li><p>JPA employs an first level cache that guarantees that for a given class and id only a single instance will get loaded into a persistence context.
In 99% of the cases this is rather nice.
But in 1% of the cases this is really confusing.
For example you can&#8217;t easily load the current state of an object from the database if you already loaded it before.</p></li><li><p>Finally JPA maintains a relationship between domain objects and the persistence context.
This is to enable dirty checking.
Again, often this is very useful.
But  it also can get very confusing when you actually don&#8217;t want to persist changes to an entity.
Or if you want to copy an entity.</p></li></ul></div>
<div class="paragraph"><p>This makes JPA hard to understand and hard to use correctly.</p></div>
<div class="paragraph"><p>Spring Data JDBC tries to be a conceptually simpler alternative.
We achieve that by not doing many things.</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>No Lazy Loading.</p></li><li><p>No write behind cache.</p></li><li><p>No cache at all. Of course you are free to add a cache on top of it.</p></li><li><p>No proxies.</p></li></ol></div>
<div class="paragraph"><p>Spring Data will save you data when you call <code>save</code> and only return once it is inserted or updated in the database.
It will not save data you haven&#8217;t invoked <code>save</code> for.
All data will be fully loaded within the method call that loads the data.</p></div>
<div class="paragraph"><p>Try the following examples.
Also inspect the logs to see what kind of interaction is happening with the database.</p></div>
<pre class="CodeRay listingblock"><code class="java language-java">Speaker martin = new Speaker();
martin.name = "Martin Fowler";
Speaker saved = speakers.save(martin);
assertThat(saved.id).isNotNull();


saved.id = null;

Speaker savedAgain = speakers.save(martin);

assertThat(savedAgain.id).isNotNull();

assertThat(speakers.findAll()).hasSize(2);</code></pre>
<pre class="CodeRay listingblock"><code class="java language-java">Speaker martin = new Speaker();
martin.name = "Martin Fowler";
Speaker saved = speakers.save(martin);
assertThat(saved.id).isNotNull();

Optional&lt;Speaker&gt; loaded = speakers.findById(saved.id);
Optional&lt;Speaker&gt; reloaded = speakers.findById(saved.id);

assertThat(loaded.get())
		.isEqualTo(reloaded.get())
		.isNotSameAs(reloaded.get());</code></pre>
<div class="paragraph"><p>While this  makes things simpler it brings some extra challenges.
We&#8217;ll see those later and how to tackle them.</p></div></section>
<section id="_storing_relationships"><h2>Storing Relationships</h2><div class="paragraph"><p>Let&#8217;s make <code>Speakers</code> more interesting.
Each speaker should have a <code>Map</code> of <code>Website</code> references.
Like so:</p></div>
<pre class="CodeRay listingblock"><code class="java language-java">@EqualsAndHashCode
@ToString
@AllArgsConstructor
class Website {

	String link;
	String title;
}</code></pre>
<div class="paragraph"><p>Add the following line to the <code>Speaker</code> class.</p></div>
<pre class="CodeRay listingblock"><code class="java language-java">Map&lt;String, Website&gt; websites = new HashMap&lt;&gt;();</code></pre>
<div class="paragraph"><p>Of course we need adapt our schema as well.
Add the following to the <code>schema.sql</code> file.</p></div>
<pre class="CodeRay listingblock"><code class="sql language-sql">CREATE TABLE WEBSITE
(
  SPEAKER     BIGINT,
  SPEAKER_KEY VARCHAR(20),
  LINK        VARCHAR(200),
  TITLE       VARCHAR(200),
  PRIMARY KEY (SPEAKER, SPEAKER_KEY)
);</code></pre>
<div class="paragraph"><p>Note that the table has two extra columns.
One for a backreference to <code>SPEAKER</code> and one for the map key.</p></div>
<div class="paragraph"><p>Create a test to play around with <code>Speaker</code> and <code>Website</code>.</p></div>
<div class="paragraph"><p>For example.</p></div>
<pre class="CodeRay listingblock"><code class="java language-java">Speaker martin = new Speaker();
martin.name = "Martin Fowler";
martin.websites.put("main", new Website("https://martinfowler.com/", "Martin Fowler"));
martin.websites.put("wikipedia", new Website("https://en.wikipedia.org/wiki/Martin_Fowler", "Martin Fowler - Wikipedia"));

Speaker saved = speakers.save(martin);
assertThat(saved.id).isNotNull();

Speaker reloaded = speakers.findById(saved.id).get();

reloaded.websites.get("wikipedia").title = "Martin Fowler on Wikipedia";

speakers.save(reloaded);

speakers.delete(reloaded);</code></pre>
<div class="paragraph"><p>Take a look at the SQL used.
Do you have questions?</p></div></section>
<section><section id="_aggregates_in_ddd_and_mx_relationships_spring_data_jdbc"><h2>Aggregates in DDD and M:x Relationships Spring Data JDBC</h2><div class="paragraph"><p>In the last example you could observe that deleting a <code>Speaker</code> deleted  all the <code>Website</code> instances.
Currently even an update does that.
In the update case there are improvements planned so that only those actually removed from a collection get deleted.
But those that get removed from the collection still will get deleted and so are those referenced by a <code>Speaker</code> that gets deleted.</p></div><div class="paragraph"><p>If we are only interested in a <code>Website</code> in the context of a <code>Speaker</code> this is ok.
It is basically the <code>CascadeType.ALL</code> pluse <code>orphanRemoval = true</code> or in older versions <code>CascadeType.DELETE_ORPHAN</code>
But what if we don&#8217;t want this behavior?</p></div><div class="paragraph"><p>For an example let&#8217;s add a domain class <code>Talk</code> which has a list of <code>Speaker</code> instances.
We don&#8217;t want to delete a <code>Speaker</code> when a <code>Talk</code> is deleted or even just updated.
That <code>Speaker</code> might be doing other talks after all.</p></div><div class="paragraph"><p>At this point it is instructive to take a step back and take a look at what we are doing conceptually.
A <code>Repository</code> is a concept from Domain Driven Design.
It loads and saves "aggregates".
"What is an aggregate?" you ask.</p></div><div class="paragraph"><p>Let&#8217;s hear Martin Fowler.</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>A DDD aggregate is a cluster of domain objects that can be treated as a single unit.
 [&#8230;&#8203;]
 Aggregates are the basic element of transfer of data storage - you request to load or save whole aggregates.</p></div></blockquote></div><div class="paragraph"><p>Closely related to aggregates is the "aggregate root"</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>An aggregate will have one of its component objects be the aggregate root.
  Any references from outside the aggregate should only go to the aggregate root.
  The root can thus ensure the integrity of the aggregate as a whole.</p></div></blockquote></div><div class="paragraph"><p>Spring Data JDBC saves, loads and deletes aggregates.
This fits the approach of deleting everything.
It also suggests that if we don&#8217;t want to delete a <code>Speaker</code> when we delete a <code>Talk</code> that <code>Speaker</code> and <code>Talk</code> are different aggregates.
This is actually true for all to many-to-many or many-to-one relationships.
Because in all these cases the life cycle of the two sides of the relationship are independent of each other.</p></div><div class="paragraph"><p>But all this still doesn&#8217;t answer the question how to actually model these references between aggregates.</p></div><div class="paragraph"><p>So lets ask David Masters</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>It makes life much easier if you just keep a reference of the aggregateâ€™s ID rather than the actual aggregate itself.</p></div></blockquote></div><div class="paragraph"><p>Or Vaughn Vernon <em>Domain-Driven Design Distilled (Kindle Locations 1087-1088). Pearson Education. Kindle Edition.</em></p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>Reference other Aggregates by identity only.</p></div></blockquote></div><div class="paragraph"><p>With this approach our original problem just disappears.
Since in the domain model there is just an id, Spring Data JDBC doesn&#8217;t even have the necessary knowledge to delete the referenced entity or aggregate.</p></div><div class="paragraph"><p>So lets do that for the <code>Talk</code> class.</p></div><pre class="CodeRay listingblock"><code class="java language-java">@ToString
@EqualsAndHashCode
class Talk {

	@Id
	Long id;
	String title;
	List&lt;Long&gt; speakerIds = new ArrayList&lt;&gt;();

	Talk(String title) {
		this.title = title;
	}

	void addSpeakers(Speaker... speakers) {

		for (Speaker speaker : speakers) {
			addSpeaker(speaker);
		}
	}

	private void addSpeaker(Speaker speaker) {

		assert speaker != null;
		assert speaker.id != null;

		speakerIds.add(speaker.id);
	}
}</code></pre><pre class="CodeRay listingblock"><code class="java language-java">interface TalkRepository extends CrudRepository&lt;Talk, Long&gt; { }</code></pre><pre class="CodeRay listingblock"><code class="java language-java">@RunWith(SpringRunner.class)
@DataJdbcTest
public class AggregateReferenceTests {

	@Autowired
	SpeakerRepository speakers;

	@Autowired
	TalkRepository talks;

	@Test
	public void speakerAndTalks() {

		Speaker steven = speaker("Steven Schwenke");
		Speaker tim = speaker("Tim Bourguignon");

		speakers.saveAll(asList(steven, tim));

		Talk teams = new Talk("Managing Distributed Teams");
		teams.addSpeakers(steven);

		Talk mentoring = new Talk("Mentoring Speed Dating");
		mentoring.addSpeakers(steven, tim);

		Talk unicorns = new Talk("Why Unicorn Developers don't Grow on Trees?");
		unicorns.addSpeakers(tim);

		talks.saveAll(asList(teams, mentoring, unicorns));

		assertThat(speakers.count()).isEqualTo(2);
		assertThat(talks.count()).isEqualTo(3);

		talks.delete(teams);

		assertThat(speakers.count()).isEqualTo(2);
		assertThat(talks.count()).isEqualTo(2);

		assertThat(talks.findById(mentoring.id).get().speakerIds).containsExactlyInAnyOrder(tim.id, steven.id);
	}

	private Speaker speaker(String name) {

		Speaker speaker = new Speaker();
		speaker.name = name;
		return speaker;
	}
}</code></pre><pre class="CodeRay listingblock"><code class="sql language-sql">CREATE TABLE TALK
(
  ID   BIGINT GENERATED BY DEFAULT AS IDENTITY (START WITH 1) PRIMARY KEY,
  TITLE VARCHAR(200),
  SPEAKER_IDS BIGINT ARRAY
);</code></pre><div class="paragraph"><p>This approach uses a <code>BIGINT ARRAY</code> to store the references in the database.
This has the benefit of getting loaded and saved in a single statement.
But it also comes with drawbacks, like not all databases supporting it and those that do might not support foreign keys.</p></div><div class="paragraph"><p>You can achieve the same with a traditional mapping table.
For demoing that let&#8217;s introduce conferences which have a M:N relationship to talks:</p></div><pre class="CodeRay listingblock"><code class="java language-java">@ToString
@EqualsAndHashCode
class Conference {

	@Id
	Long id;
	String name;
	LocalDate startDate;

	Set&lt;TalkReference&gt; talks = new HashSet&lt;&gt;();

	Conference(String name, LocalDate startDate) {
		this.name = name;
		this.startDate = startDate;
	}

	void addTalks(Talk... talks) {

		for (Talk talk : talks) {
			this.addTalk(talk);
		}
	}

	private void addTalk(Talk talk) {

		assert talk != null;
		assert talk.id != null;

		talks.add(new TalkReference(talk.id));
	}
}</code></pre><pre class="CodeRay listingblock"><code class="java language-java">@Value
@Table("CONFERENCE_TALK")
public class TalkReference {
    @Column("TALK")
	Long talkId;
}</code></pre><pre class="CodeRay listingblock"><code class="java language-java">interface ConferenceRepository extends CrudRepository&lt;Conference, Long&gt; { }</code></pre><pre class="CodeRay listingblock"><code class="sql language-sql">CREATE TABLE CONFERENCE
(
  ID   BIGINT GENERATED BY DEFAULT AS IDENTITY (START WITH 1),
  NAME VARCHAR(200),
  START_DATE DATE,
  CONSTRAINT PK_CONFERENCE PRIMARY KEY (ID)
);

CREATE TABLE CONFERENCE_TALK
(
  CONFERENCE BIGINT,
  TALK       BIGINT,
  PRIMARY KEY (CONFERENCE, TALK)
);

ALTER TABLE CONFERENCE_TALK
  ADD CONSTRAINT FK_CONFERENCE_TALK_CONFERENCE FOREIGN KEY (CONFERENCE) REFERENCES CONFERENCE (ID);
ALTER TABLE CONFERENCE_TALK
  ADD CONSTRAINT FK_CONFERENCE_TALK_TALK FOREIGN KEY (TALK) REFERENCES TALK (ID);</code></pre><pre class="CodeRay listingblock"><code class="java language-java">@Test
public void talksAndConferences() {

	Talk teams = new Talk("Managing Distributed Teams");
	Talk mentoring = new Talk("Mentoring Speed Dating");
	Talk unicorns = new Talk("Why Unicorn Developers don't Grow on Trees?");

	talks.saveAll(asList(teams, mentoring, unicorns));

	Conference javaLand = new Conference("JavaLand", LocalDate.parse("2020-03-17", DateTimeFormatter.ISO_DATE));
	javaLand.addTalks(teams, mentoring, unicorns);

	Conference javaForum = new Conference("Java Forum Nord", LocalDate.parse("2019-09-24", DateTimeFormatter.ISO_DATE));
	javaForum.addTalks(teams, mentoring);

	conferences.saveAll(asList(javaLand, javaForum));
}</code></pre></section><section id="_but_why"><h2>But Why?</h2><div class="paragraph"><p>Handling ids manually is cumbersome.
Why would one want to do that?</p></div>
<div class="paragraph"><p>Because it breaks the domain in modules.
And this has all kinds of positiv effects.</p></div>
<div class="ulist"><ul><li><p>It is now really easy to understand what get loaded and saved in one go.</p></li><li><p>The persistence question may now be answered for every aggregate separately.
Since you are loading it from an repository anyway you might as well store it in a different database.</p></li><li><p>You might rethink foreign keys between aggregates.</p><div class="ulist"><ul><li><p>Using deferred constraints may help with integration tests, because you no longer need to create all referenced entities.</p></li><li><p>Dropping foreign keys completely between aggregates is a sensible way to eventual consistency.</p></li></ul></div></li><li><p>Eventually the boundaries between aggregates might turn into boundaries between microservices.</p></li></ul></div></section><section id="_congratulations"><h2>Congratulations</h2><div class="paragraph"><p>Understanding aggregates is the most important part of this workshop.
Note that you may use this approach independent of Spring Data JDBC in order to achieve a modular domain model.</p></div></section></section>
<section id="_events_and_id_generation"><h2>Events and Id Generation</h2><div class="paragraph"><p>So far ids where generated by id columns in the database.
There are various reasons why this might be undesirable.</p></div>
<div class="paragraph"><p>I princple there are two different scenarios:</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>You still want to create the id when the data gets stored in the database.</p></li><li><p>New entities already have an id that should be used.</p></li></ol></div>
<div class="paragraph"><p>For the first part let&#8217;s use UUIDs for the primary key.</p></div>
<div class="paragraph"><p>Let&#8217;s create an entity and the matching table.</p></div>
<pre class="CodeRay listingblock"><code class="java language-java">class UuidEntity {

    @Id
	UUID id;

	String name;
}</code></pre>
<pre class="CodeRay listingblock"><code class="sql language-sql">CREATE TABLE UUID_ENTITY
(
  ID   UUID PRIMARY KEY,
  NAME VARCHAR(200)
)</code></pre>
<div class="paragraph"><p>This doesn&#8217;t work since we need to create Ids.
We do that in a callback.</p></div>
<pre class="CodeRay listingblock"><code class="java language-java">@Bean
BeforeConvertCallback&lt;UuidEntity&gt; uuidGenerator() {
	return new BeforeConvertCallback&lt;UuidEntity&gt;() {
		@Override
		public UuidEntity onBeforeConvert(UuidEntity aggregate) {
			aggregate.id = UUID.randomUUID();
			return aggregate;
		}
	};
}</code></pre>
<div class="paragraph"><p>Or written as a closure</p></div>
<pre class="CodeRay listingblock"><code class="java language-java">@Bean
BeforeConvertCallback&lt;UuidEntity&gt; uuidGenerator() {
	return aggregate -&gt; {
		aggregate.id = UUID.randomUUID();
		return aggregate;
	};
}</code></pre>
<div class="paragraph"><p>This is what is happening under the hood:
Spring Data notices that the id is <code>null</code> and therefore determines that it is  a new entity.
The callback then sets the id and Spring Data continues to convert it and to store it with the generated id in the database.</p></div>
<div class="paragraph"><p>This makes it obvious why we need a different strategy for the case where the id is set a priori.
If the id is already set Spring Data considers it an existing entity by default and performs and update instead</p></div>
<div class="paragraph"><p>Lets create another example how to handle this.
There are two fundamentel different ways to achieve this.
The first approach is to code the information if an entity is new or not into the entity by letting it implement <code>Persistable</code>.</p></div>
<pre class="CodeRay listingblock"><code class="java language-java">@Table("UUID_ENTITY")
class UuidEntityPresetId implements Persistable {

	@Id
	UUID id;

	String name;

	@Transient
	boolean isNew;

	@PersistenceConstructor
	UuidEntityPresetId(UUID id, String name) {
		this.id = id;
		this.name = name;
		this.isNew = false;
	}

	UuidEntityPresetId(String name) {
		id = UUID.randomUUID();
		this.name = name;
		this.isNew = true;
	}

	@Override
	public Object getId() {
		return id;
	}

	@Override
	public boolean isNew() {
		return isNew;
	}
}</code></pre>
<div class="paragraph"><p>For this we use the field <code>isNew</code> which needs to get updated to <code>false</code> after the entity got saved for the first time.
For this we need another callback</p></div>
<pre class="CodeRay listingblock"><code class="java language-java">@Bean
AfterSaveCallback&lt;UuidEntityPresetId&gt; markAsSaved() {
	return aggregate -&gt; {
		aggregate.isNew = false;
		return aggregate;
	};
}</code></pre>
<div class="paragraph"><p>The flag shouldn&#8217;t get saved to the database which is why it is marked as <code>@Transient</code>.</p></div>
<div class="paragraph"><p>For the other variant we first need to introduce custom methods</p></div></section>
<section id="_custom_methods"><h2>Custom Methods</h2><div class="paragraph"><p>Custom methods are methods in your repository for which you provide the implementation yourself.
As an example we implement an <code>insert</code> method that does a directe insert without checking if the entity is new or not.</p></div>
<div class="paragraph"><p>First we need an interface to hold the custom methods we want to add.</p></div>
<pre class="CodeRay listingblock"><code class="java language-java">public interface CustomRepository {
	void insert(UuidEntityExternalyControlledId entity);
}</code></pre>
<div class="paragraph"><p>Our repository needs to extend the interface</p></div>
<pre class="CodeRay listingblock"><code class="java language-java">public interface UuidEntityExternalyControlledIdRepository
        extends
        CrudRepository&lt;UuidEntityExternalyControlledId, UUID&gt;,
        CustomRepository {}</code></pre>
<div class="paragraph"><p>And we need to provide an implementation with the same name as the interface plus an added <code>Impl</code>.
The implementation gets autowired just as a bean so we can inject stuff we need.</p></div>
<div class="paragraph"><p>In this case we need <code>JdbcAggregateOperations</code> which offers an <code>insert</code> method which we can use.</p></div>
<pre class="CodeRay listingblock"><code class="java language-java">public class CustomRepositoryImpl implements CustomRepository {

	@Autowired
	JdbcAggregateOperations operations;

	public void insert(UuidEntityExternalyControlledId entity){
		operations.insert(entity);
	};
}</code></pre></section>
<section id="_query_annotation"><h2>@Query Annotation</h2><div class="paragraph"><p>So far we talked almost exclusively about CRUD operations.
But an important part of working with a relational database is querying.</p></div>
<div class="paragraph"><p>You can perform arbitrary queries using the <code>@Query</code> annotation.
Let&#8217;s take a look at a couple example based on talks, speakers and conferences used at the beginning.</p></div>
<div class="paragraph"><p>You can query for scalar values.</p></div>
<pre class="CodeRay listingblock"><code class="java language-java">@Query("select count(*) " +
	"from Conference_Talk ct " +
	"join Talk t " +
	"on ct.talk = t.id " +
	"where :speakerId in (unnest(t.speaker_ids))")
int countInstancesWith(Long speakerId);</code></pre>
<div class="paragraph"><p>You can query for aggregates.</p></div>
<pre class="CodeRay listingblock"><code class="java language-java">@Query("Select * from conference where start_date &gt; :threshold order by start_date limit 1 offset 0")
Conference nextConferenceAfter(LocalDate threshold);</code></pre>
<div class="paragraph"><p>You can use various wrappers (<code>List</code>, <code>Optional</code> &#8230;&#8203;)</p></div>
<pre class="CodeRay listingblock"><code class="java language-java">@Query("Select * from conference where start_date &gt; :threshold order by start_date")
List&lt;Conference&gt; conferencesAfter(LocalDate threshold);</code></pre>
<div class="paragraph"><p>You can execute DML statements, e.g. updates. They just require an additional <code>@Modifying</code>.</p></div>
<pre class="CodeRay listingblock"><code class="java language-java">@Modifying
@Query("update talk t " +
	"set title = " +
	"title || ' (with ' || (select s.name from speaker s where s.id = t.speaker_ids[1])  || ')' ")
void addSpeakerToTitle();</code></pre>
<div class="paragraph"><p>For even more flexibility you can specify a <code>ResultSetExtractor</code> or <code>RowMapper</code> to be used.
These are classes from <em>Spring JDBC</em>. Note that there is no <em>Data</em> in <em>Spring JDBC</em>.
The <code>RowMapper</code> or <code>ResultSetExtractor</code> class get specified in the query annotation as using the <code>resultExtractorClass</code> or <code>rowMapperClass</code> attributes as in the following example.</p></div>
<pre class="CodeRay listingblock"><code class="java language-java">@Query(value = "select t.title, c.name " +
		"from talk t " +
		"join conference_talk ct on t.id = ct.talk " +
		"join conference c on c.id = ct.conference " +
		"order by t.title"
		, resultSetExtractorClass = TalkInfoExtractor.class
)
List&lt;TalkInfo&gt; talkInfos();</code></pre>
<div class="paragraph"><p>The example needs a <code>TalkInfo</code> class and the <code>TalkInfoExtractor</code> class.</p></div>
<pre class="CodeRay listingblock"><code class="java language-java">class TalkInfo {

	private final String title;
	private final Set&lt;String&gt; conferenceTitles = new HashSet&lt;&gt;();


	TalkInfo(String title) {
		this.title = title;
	}

	void addConference(String name) {
		conferenceTitles.add(name);
	}
}</code></pre>
<pre class="CodeRay listingblock"><code class="java language-java">public class TalkInfoExtractor implements ResultSetExtractor {
	@Override
	public Object extractData(ResultSet resultSet) throws SQLException, DataAccessException {

		String currentTalk = "";
		List&lt;TalkInfo&gt; result = new ArrayList&lt;&gt;();

		while (resultSet.next()) {
			String talkName = resultSet.getString(1);
			if (result.isEmpty() || !currentTalk.equals(talkName)) {
				result.add(new TalkInfo(talkName));
				currentTalk = talkName;
			}
			result.get(result.size()-1).addConference(resultSet.getString(2));
		}

		return result;
	}
}</code></pre>
<div class="paragraph"><p>All statements are executed directly.
If you don&#8217;t limit yourself to standard SQL the statements are not portable.
There are plans to have queries externalized in property files and have separate statements per database but that is not there yet.</p></div></section>
<section><section id="_more_mapping"><h2>More Mapping</h2><div class="paragraph"><p>So far we used almost exclusively the default mapping behaviour of <em>Spring Data JDBC</em> but there are ways to customize the behaviour and also some kinds of mapping that we didn&#8217;t mention yet.</p></div></section><section id="_general_class_requirements"><h2>General class requirements</h2><div class="paragraph"><p>Spring Data JDBC can use a default constructor for instantiating entities.
It also accepts constructors which take some or all of the attributes as arguments.
In this case the names of the constructor parameters must match the names of the attributes.
If there is more than one constructor one needs to be marked as the one to use with <code>@PersistenceConstructor</code>.</p></div>
<div class="paragraph"><p>Attributes that didn&#8217;t get set by the constructor get set by
* setter
* "wither"
* or direct field access</p></div>
<div class="paragraph"><p>A "wither" is a setter for an immutable object. It uses the prefix <code>with</code> instead of <code>set</code> and since the attribute value can not be changed it instead returns a new instance with the attribute set to the argument value.</p></div>
<div class="paragraph"><p>"Wither" can be easily produced by Lombok or written by hand.
Kotlin data objects work as well.</p></div></section><section id="_simple_types"><h2>Simple Types</h2><div class="paragraph"><p>Simple Types are those that can get stored in a single column.
Examples are</p></div>
<div class="ulist"><ul><li><p>String</p></li><li><p>primitive types and their boxed siblings</p></li><li><p>BigInteger, BigDecimal</p></li><li><p>Various Date related types</p></li><li><p>Enum</p></li></ul></div></section><section id="_names"><h2>Names</h2><div class="paragraph"><p>The column name for an attribute is the attributes name converted to <em>snake-case</em>.
For example <code>dateOfBirth</code> becomes <code>date_of_birth</code></p></div>
<div class="paragraph"><p>You may customize the column name of an attribute using an <code>@Column</code> annotation.</p></div>
<pre class="CodeRay listingblock"><code class="java language-java">@Column("dob")</code></pre></section><section id="_namingstrategy"><h2>NamingStrategy</h2><div class="paragraph"><p>If you want to change how columns and tables are named in general you can register your own <code>NamingStrategy</code></p></div>
<pre class="CodeRay listingblock"><code class="java language-java">@Bean
NamingStrategy namingStrategy() {
	return new NamingStrategy(){
		@Override
		public String getTableName(Class&lt;?&gt; type) {
			return "T_" + NamingStrategy.super.getTableName(type);
		}
	};
}</code></pre></section><section id="_collections_arrays"><h2>Collections &amp; Arrays</h2><div class="paragraph"><p>We mentioned collections in the form of attributes of type <code>Map</code> shortly before we dug into aggregates.</p></div>
<div class="paragraph"><p>You can use the following types of references to other entities</p></div>
<div class="ulist"><ul><li><p><code>Set&lt;ENTITY&gt;</code></p></li><li><p><code>List&lt;ENTITY&gt;</code></p></li><li><p><code>Map&lt;SIMPLE, ENTITY&gt;</code></p></li></ul></div>
<div class="paragraph"><p>Here <code>ENTITY</code> is the type of an entity while <code>SIMPLE</code> is a simple type.</p></div>
<div class="paragraph"><p>The table for the referenced type needs an additional column named after the name of the referencing class.
<code>List</code> and <code>Map</code> need an additional column to hold the index or key.
This column again is named after the name of the referencing class with an additional <code>_KEY</code> suffix.
The names of these additional columns may be customized with a <code>MappedCollection</code> annotation.</p></div>
<pre class="CodeRay listingblock"><code class="java language-java">@MappedCollection(idColumn = "redner", keyColumn = "index")
Map&lt;String, Website&gt; websites = new HashMap&lt;&gt;();</code></pre>
<div class="paragraph"><p>Referenced entities in <code>List</code> or <code>Map</code> instances don&#8217;t need an id.
The combination of back reference and key column form are used as a primary key instead.</p></div>
<div class="paragraph"><p>A list or array of a simple type will get stored as an <code>ARRAY</code> if the database supports it.</p></div></section><section id="_embeddable"><h2>Embeddable</h2><div class="paragraph"><p>If reference to an entity is annotated with <code>@Embedded</code> the attributes of the referenced type are included in the referencing table.
The <code>onEmpty</code> attribute of the annotation determines how to deal with all <code>null</code> values.
Should it result in a <code>null</code> embedded instance or an instance with all attributes set to <code>null</code>?
The <code>prefix</code> attribute defines a prefix to be used for the columns of the embedded instance.</p></div>
<div class="paragraph"><p>For example you might want to add this to the <code>Speaker</code> class.</p></div>
<pre class="CodeRay listingblock"><code class="java language-java">@Embedded(onEmpty = Embedded.OnEmpty.USE_NULL)
ContactInfo contact;</code></pre>
<pre class="CodeRay listingblock"><code class="java language-java">class ContactInfo {
	String phone;
	String email;
}</code></pre></section><section id="_custom_conversions"><h2>Custom Conversions</h2><div class="paragraph"><p>You can register custom conversions if you want to control how values get written to the database or read from it.
As an example we introduce a custom <code>Email</code> class.</p></div>
<pre class="CodeRay listingblock"><code class="java language-java">@Value
class Email {
	String localPart;
	String domain;
}</code></pre>
<div class="paragraph"><p>We need to create two converters in order to write and read it to and from the database.</p></div>
<pre class="CodeRay listingblock"><code class="java language-java">@WritingConverter
enum EmailToStringConverter implements Converter&lt;Email, String&gt; {

	INSTANCE;

	@Override
	public String convert(Email source) {
		if (source == null) {
			return null;
		}

		{
			return source.getLocalPart() + "@" + source.getDomain();
		}
	}
}</code></pre>
<pre class="CodeRay listingblock"><code class="java language-java">@ReadingConverter
enum StringToEmailConverter implements Converter&lt;String, Email&gt; {

	INSTANCE;

	@Override
	public Email convert(String source) {
		if (source == null) {
			return null;
		}

		String[] split = source.split("@");

		if (split.length != 2) {
			throw new IllegalArgumentException("Can't parse %s into a Email. Expecting exactly one @");
		}

		return new Email(split[0], split[1]);
	}
}</code></pre>
<div class="paragraph"><p>And we need to register these converters as <code>JdbcCustomConversions</code>.
For this we let our configuration extend <code>AbstractJdbcConfiguration</code> and overwrite the <code>jdbcCuostomConversions()</code> bean method.</p></div>
<pre class="CodeRay listingblock"><code class="java language-java">@SpringBootApplication
public class DemoApplication extends AbstractJdbcConfiguration {

    // .. other code that we might have here so far

	@Bean
	@Override
	public JdbcCustomConversions jdbcCustomConversions() {
		return new JdbcCustomConversions(asList(EmailToStringConverter.INSTANCE, StringToEmailConverter.INSTANCE));
	}

}</code></pre>
<div class="paragraph"><p>Now we can replace the email <code>String</code> in <code>ContactInfo</code> with a proper class</p></div>
<pre class="CodeRay listingblock"><code class="java language-java">class ContactInfo {
	String phone;
	Email email;
}</code></pre></section><section id="_bidirectional_relationships"><h2>Bidirectional Relationships</h2><div class="paragraph"><p>Bidirectional Relationships aren&#8217;t directly supported.</p></div>
<div class="paragraph"><p>For relations between aggregates appropriate query method should be added to the repositories.</p></div>
<div class="paragraph"><p>Bidirectional relationships inside an aggregate shouldn&#8217;t be necessary because any access should happen from the aggregate root.
If it is still wanted it must be established using setters, constructors and event listeners.</p></div></section></section></div></div><script src="reveal.js-3.7.0/lib/js/head.min.js"></script><script src="reveal.js-3.7.0/js/reveal.js"></script><script>Array.prototype.slice.call(document.querySelectorAll('.slides section')).forEach(function(slide) {
  if (slide.getAttribute('data-background-color')) return;
  // user needs to explicitly say he wants CSS color to override otherwise we might break custom css or theme (#226)
  if (!(slide.classList.contains('canvas') || slide.classList.contains('background'))) return;
  var bgColor = getComputedStyle(slide).backgroundColor;
  if (bgColor !== 'rgba(0, 0, 0, 0)' && bgColor !== 'transparent') {
    slide.setAttribute('data-background-color', bgColor);
    slide.style.backgroundColor = 'transparent';
  }
})

// See https://github.com/hakimel/reveal.js#configuration for a full list of configuration options
Reveal.initialize({
  // Display presentation control arrows
  controls: true,
  // Help the user learn the controls by providing hints, for example by
  // bouncing the down arrow when they first encounter a vertical slide
  controlsTutorial: true,
  // Determines where controls appear, "edges" or "bottom-right"
  controlsLayout: 'bottom-right',
  // Visibility rule for backwards navigation arrows; "faded", "hidden"
  // or "visible"
  controlsBackArrows: 'faded',
  // Display a presentation progress bar
  progress: true,
  // Display the page number of the current slide
  slideNumber: false,
  // Control which views the slide number displays on
  showSlideNumber: 'all',
  // Push each slide change to the browser history
  history: true,
  // Enable keyboard shortcuts for navigation
  keyboard: true,
  // Enable the slide overview mode
  overview: true,
  // Vertical centering of slides
  center: true,
  // Enables touch navigation on devices with touch input
  touch: true,
  // Loop the presentation
  loop: false,
  // Change the presentation direction to be RTL
  rtl: false,
  // Randomizes the order of slides each time the presentation loads
  shuffle: false,
  // Turns fragments on and off globally
  fragments: true,
  // Flags whether to include the current fragment in the URL,
  // so that reloading brings you to the same fragment position
  fragmentInURL: false,
  // Flags if the presentation is running in an embedded mode,
  // i.e. contained within a limited portion of the screen
  embedded: false,
  // Flags if we should show a help overlay when the questionmark
  // key is pressed
  help: true,
  // Flags if speaker notes should be visible to all viewers
  showNotes: false,
  // Global override for autolaying embedded media (video/audio/iframe)
  // - null: Media will only autoplay if data-autoplay is present
  // - true: All media will autoplay, regardless of individual setting
  // - false: No media will autoplay, regardless of individual setting
  autoPlayMedia: null,
  // Number of milliseconds between automatically proceeding to the
  // next slide, disabled when set to 0, this value can be overwritten
  // by using a data-autoslide attribute on your slides
  autoSlide: 0,
  // Stop auto-sliding after user input
  autoSlideStoppable: true,
  // Use this method for navigation when auto-sliding
  autoSlideMethod: Reveal.navigateNext,
  // Specify the average time in seconds that you think you will spend
  // presenting each slide. This is used to show a pacing timer in the
  // speaker view
  defaultTiming: 120,
  // Enable slide navigation via mouse wheel
  mouseWheel: false,
  // Hides the address bar on mobile devices
  hideAddressBar: true,
  // Opens links in an iframe preview overlay
  // Add `data-preview-link` and `data-preview-link="false"` to customise each link
  // individually
  previewLinks: false,
  // Transition style (e.g., none, fade, slide, convex, concave, zoom)
  transition: 'linear',
  // Transition speed (e.g., default, fast, slow)
  transitionSpeed: 'default',
  // Transition style for full page slide backgrounds (e.g., none, fade, slide, convex, concave, zoom)
  backgroundTransition: 'fade',
  // Number of slides away from the current that are visible
  viewDistance: 3,
  // Parallax background image (e.g., "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'")
  parallaxBackgroundImage: '',
  // Parallax background size in CSS syntax (e.g., "2100px 900px")
  parallaxBackgroundSize: '',
  // Number of pixels to move the parallax background per slide
  // - Calculated automatically unless specified
  // - Set to 0 to disable movement along an axis
  parallaxBackgroundHorizontal: null,
  parallaxBackgroundVertical: null,
  // The display mode that will be used to show slides
  display: 'block',

  // The "normal" size of the presentation, aspect ratio will be preserved
  // when the presentation is scaled to fit different resolutions. Can be
  // specified using percentage units.
  width: 1280,
  height: 720,

  // Factor of the display size that should remain empty around the content
  margin: 0,

  // Bounds for smallest/largest possible scale to apply to content
  minScale: 0.2,
  maxScale: 1.5,

  // Optional libraries used to extend on reveal.js
  dependencies: [
      { src: 'reveal.js-3.7.0/lib/js/classList.js', condition: function() { return !document.body.classList; } },
      
      { src: 'reveal.js-3.7.0/plugin/zoom-js/zoom.js', async: true },
      { src: 'reveal.js-3.7.0/plugin/notes/notes.js', async: true },
      
      
      
      
  ],

  

});</script></body></html>